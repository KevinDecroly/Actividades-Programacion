Biblio DAW
Clase biblioteca


public class Biblioteca {

    // Atributo estático: pertenece a la clase, no a los objetos.
    // Cuenta el total de libros que se han insertado en TODAS las bibliotecas creadas.
    private static int contadorTotal = 0;

    // Método para obtener el contador total de libros.
    public static int getContadorTotal() {
        return contadorTotal;  // Devuelve el valor del contador.
    }

    // Atributos privados (encapsulados): solo se acceden desde métodos públicos.
    private String codigo;     // Código identificador de la biblioteca
    private String nombre;     // Nombre de la biblioteca
    private String direccion;  // Dirección física
    private String email;      // Email de contacto
    private String nTelefono;  // Número de teléfono

    // Array de libros que contiene esta biblioteca.
    private Libro[] libros; // Aquí se almacenan los libros.
    private int nLibrosActuales; // Cuántos libros hay realmente guardados.
    private final int dimensionInicial = 100; // Tamaño inicial del array

    // Constructor: se ejecuta cuando hacemos new Biblioteca(...)
    public Biblioteca(String codigo, String nombre, String direccion, String email, String nTelefono) {

        // Asignamos a los atributos los valores recibidos por parámetro.
        this.codigo = codigo;
        this.nombre = nombre;
        this.direccion = direccion;
        this.email = email;
        this.nTelefono = nTelefono;

        // Creamos el array de libros con tamaño inicial 100.
        this.libros = new Libro[this.dimensionInicial];

        // Al inicio no tenemos libros añadidos, así que empezamos en 0.
        this.nLibrosActuales = 0;
    }

    // MÉTODOS GET (para leer atributos)
    public String getCodigo() {
        return this.codigo;
    }

    public String getNombre() {
        return this.nombre;
    }

    public String getDireccion() {
        return this.direccion;
    }

    public String getEmail() {
        return this.email;
    }

    // MÉTODOS SET (para modificar atributos)
    public void setEmail(String email) {
        this.email = email;
    }

    public String getnTelefono() {
        return this.nTelefono;
    }

    public void setnTelefono(String nTelefono) {
        this.nTelefono = nTelefono;
    }

    // Método para insertar un libro en la biblioteca.
    public boolean insertarLibro(Libro libro) {

        boolean resultado = false; // Indicará si la operación fue correcta o no.

        // Primero comprobamos que el libro no sea null.
        if (libro != null) {

            // Si aún hay hueco en el array...
            if (this.nLibrosActuales < this.libros.length) {

                // Insertamos el libro en la primera posición libre.
                this.libros[this.nLibrosActuales] = libro;

                // Marcamos que se insertó correctamente.
                resultado = true;

                // Aumentamos el número de libros actuales.
                this.nLibrosActuales++;

                // Aumentamos también el contador total (estático).
                contadorTotal++;

            } else {
                // Si no hay espacio suficiente, ampliamos el array.

                this.ampliarDimensionBiblioteca(); // Creamos un array más grande.

                // Insertamos el libro ahora que hay espacio.
                this.libros[this.nLibrosActuales] = libro;
                resultado = true;
                this.nLibrosActuales++;
                contadorTotal++;
            }
        }

        return resultado; // Devolvemos el resultado de la inserción.
    }

    // Devuelve un libro buscando por su ISBN. Si no lo encuentra, devuelve null.
    public Libro getLibroByISBN(String ISBN) {

        int index = -1; // Guardará la posición donde está el libro.

        // Recorremos todos los libros actuales.
        for (int i = 0; i < this.nLibrosActuales; i++) {

            // Comprobamos que la posición no sea null
            if (this.libros[i] != null) {

                // Comparamos el ISBN ignorando mayúsculas/minúsculas.
                if (this.libros[i].getISBN().equalsIgnoreCase(ISBN)) {

                    index = i; // Guardamos la posición donde se encontró el libro.
                    break; // Salimos del bucle, ya lo encontramos.
                }
            }
        }

        // Si index sigue siendo -1, es que no lo encontramos.
        if (index == -1) {
            return null;
        } else {
            // Si lo encontramos, lo devolvemos.
            return this.libros[index];
        }
    }

    // Elimina un libro de la biblioteca
    public boolean eliminarLibro(Libro libro) {

        boolean resultado = false; // Guardará si logramos eliminar el libro.

        if (libro != null) {

            int index = -1; // Guardará la posición del libro a eliminar.

            // Buscamos el libro recorriendo el array.
            for (int i = 0; i < this.nLibrosActuales; i++) {

                if (this.libros[i] != null) {

                    // Si el ISBN coincide, encontramos el libro.
                    if (this.libros[i].getISBN().equalsIgnoreCase(libro.getISBN())) {

                        index = i;
                        break; // Salimos al encontrarlo.
                    }
                }
            }

            // Si index != -1, es que sí encontramos el libro.
            if (index != -1) {

                // Eliminamos el libro poniendo null temporalmente.
                this.libros[index] = null;

                // Marcamos operación exitosa.
                resultado = true;

                // Estrategia: mover el último libro del array a la posición eliminada.
                this.libros[index] = this.libros[nLibrosActuales - 1];

                // Borramos la última posición que ya movimos.
                this.libros[nLibrosActuales - 1] = null;

                // Reducimos el contador de libros actuales.
                this.nLibrosActuales--;
            }
        }

        return resultado; // Devolvemos si eliminamos o no.
    }

    // Devuelve la información de la biblioteca como texto.
    public String infoBiblioteca() {

        // Construimos el texto de forma eficiente.
        StringBuilder sb = new StringBuilder("Biblioteca: \n");
        sb.append("Nombre: " + this.nombre + "\n");
        sb.append("Direccion: " + this.direccion + "\n");
        sb.append("Email: " + this.email + "\n");
        sb.append("Numero telefono: " + this.nTelefono + "\n");

        return sb.toString(); // Devolvemos el texto final.
    }

    // Devuelve información de todos los libros que hay dentro.
    public String infoLibros() {

        String infoLibro = ""; // Texto donde guardaremos la información.

        // Si hay libros en la biblioteca...
        if (this.nLibrosActuales > 0) {

            // Recorremos cada posición con libros.
            for (int i = 0; i < this.nLibrosActuales; i++) {

                if (this.libros[i] != null) {

                    // Añadimos la información del libro al texto.
                    infoLibro += this.libros[i].infoLibro() + "\n";
                }
            }

        } else {
            // Si no hay libros, mostramos mensaje indicando vacío.
            infoLibro = "No hay libros en la biblioteca";
        }

        return infoLibro; // Devolvemos el texto final.
    }

    // Método privado que amplía el tamaño del array de libros.
    private void ampliarDimensionBiblioteca() {

        // Creamos un nuevo array con 5 posiciones más.
        Libro[] librosAux = new Libro[this.libros.length + 5];

        // Copiamos todos los libros actuales al nuevo array.
        for (int i = 0; i < this.libros.length; i++) {
            librosAux[i] = this.libros[i];
        }

        // Reemplazamos el array antiguo por el nuevo.
        this.libros = librosAux;
    }

}


Clase Genero
// Declaramos un enum llamado Genero.
// Un "enum" es un tipo especial en Java que permite definir una lista fija de valores posibles.
// Es decir, sirve para representar opciones limitadas, como géneros de libros.
public enum Genero {

    // Estos son los valores posibles del enum.
    // Cada uno representa un género literario.
    FANTASIA,   // Representa libros del género fantasía
    HISTORICA,  // Representa libros históricos
    SCIFI,      // Representa libros de ciencia ficción (Science Fiction)
    TERROR,     // Representa libros de terror
    POESIA;     // Representa libros de poesía

    // -------------------------------------------------------------------------------------------------------------------
    // El código de abajo está comentado porque no se está usando actualmente,
    // pero te explico para qué serviría si lo activaras:

    /*
    // Atributos que tendría cada elemento del enum.
    private int posicion;
    private String genero;

    // Constructor del enum con parámetros.
    // Cada valor del enum podría tener su propio número de posición y descripción.
    // Ejemplo de uso: FANTASIA(1, "Fantasía")
    Genero(int posicion, String genero){
        this.posicion = posicion;
        this.genero = genero;
    }

    // Getter para obtener la posición del género.
    public int getPosicion() {
        return posicion;
    }

    // Getter para obtener el nombre del género.
    public String getGenero() {
        return genero;
    }
    */
}


Clase Libro
import java.time.LocalDateTime; // Importamos LocalDateTime para obtener la fecha y hora actuales.
import java.time.format.DateTimeFormatter; // Importamos DateTimeFormatter para convertir la fecha a formato de texto.

/**
 * Clase Libro que representa un libro con todos sus datos.
 * Contiene atributos, constructores, getters, setters y un método para mostrar la información.
 */
public class Libro {

    // Atributo ESTÁTICO: pertenece a la clase y no a cada libro individual.
    // Contará cuántos libros se han creado en total para generar IDs únicos.
    private static int contadorTotal = 0;

    // Formato que usaremos para convertir la fecha actual a un texto legible.
    // Ejemplo del formato: "23-05-2024 14:32:10"
    private DateTimeFormatter dtf = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");

    // --- Atributos (campos) del libro ---
    // 'final' significa que este atributo NO puede cambiar después del constructor.
    private final int id;  
    private String titulo;         // Título del libro
    private String autor;          // Autor del libro
    private int nPaginas;          // Número de páginas del libro
    private String ISBN;           // Código ISBN del libro
    private String editora;        // Editorial que publicó el libro
    private String fechaPublicacion; // Fecha en texto cuando se publicó el libro
    private int edicion;           // Número de edición del libro

    private Genero genero;         // Género literario (usando tu enum Genero)

    // ---------------------------------------------------------------------------------------
    // Constructor con los datos mínimos necesarios para crear un libro.
    public Libro(String titulo, String autor, String ISBN, String fechaPublicacion, Genero genero) {

        // Asignamos los valores recibidos a los atributos del objeto (this.nombre = parámetro).
        this.titulo = titulo;
        this.autor = autor;
        this.ISBN = ISBN;
        this.fechaPublicacion = fechaPublicacion; // ⚠️ Luego será sobrescrita por la fecha actual.
        this.genero = genero;

        // Valores por defecto si no se especifican.
        this.edicion = 1;             // Por defecto, primera edición.
        this.nPaginas = 1;            // Por defecto, al menos 1 página.
        this.editora = "Auto-Publicacion"; // Si no se indica editorial.

        // Asignamos un ID único al libro usando el contador estático.
        this.id = contadorTotal;
        contadorTotal++; // Aumentamos el contador para el próximo libro.

        // Sobrescribimos la fecha recibida y usamos la fecha y hora actuales del sistema.
        this.fechaPublicacion = LocalDateTime.now().format(dtf);
    }

    // ---------------------------------------------------------------------------------------
    // Segundo constructor: permite crear un libro especificando todos los detalles.
    public Libro(String titulo, String autor, String ISBN, String fechaPublicacion,
                 String editora, int edicion, int nPaginas) {

        // Asignamos los valores recibidos
        this.titulo = titulo;
        this.autor = autor;
        this.ISBN = ISBN;
        this.fechaPublicacion = fechaPublicacion; // También será sobrescrita luego
        this.edicion = edicion;
        
        // Para nPaginas usamos el setter porque incluye validación (no permite números negativos)
        this.setnPaginas(nPaginas);
        
        this.editora = editora;

        // Asignamos ID único igual que antes
        this.id = contadorTotal;
        contadorTotal++;

        // Sobrescritura con la fecha actual con formato
        this.fechaPublicacion = LocalDateTime.now().format(dtf);
    }

    // ---------------------------------------------------------------------------------------
    // GETTERS Y SETTERS (permiten acceder/modificar atributos de forma controlada)

    public int getId() {
        return id; // El ID es final, por eso no existe un setter.
    }

    public String getTitulo() {
        return this.titulo;
    }

    public String getAutor() {
        return this.autor;
    }

    public String getISBN() {
        return this.ISBN;
    }

    public String getFechaPublicacion() {
        return this.fechaPublicacion;
    }

    public int getEdicion() {
        return this.edicion;
    }

    public void setEdicion(int edicion) {
        this.edicion = edicion; // Cambiamos la edición a la nueva que nos pasan
    }

    public int getnPaginas() {
        return this.nPaginas; // Devolvemos el número de páginas
    }

    // Setter para las páginas con validación
    public void setnPaginas(int nPaginas) {
        // Si el número de páginas es mayor que 0, lo aceptamos
        if(nPaginas > 0){
            this.nPaginas = nPaginas;
        }
        else{
            // Si el valor es 0 o negativo, asignamos una página como mínimo
            if(this.nPaginas < 1){
                this.nPaginas = 1;
            }
        }
    }

    public String getEditora() {
        return this.editora;
    }

    public void setEditora(String editora) {
        this.editora = editora; // Cambiamos la editorial
    }

    // ---------------------------------------------------------------------------------------
    // Método que devuelve un texto con toda la información del libro
    public String infoLibro(){

        // Generamos una cadena con saltos de línea para mostrar los datos de forma ordenada
        String infoLibro = "";
        infoLibro = "Titulo: " + this.titulo + "\n";
        infoLibro += "Autor: " + this.autor + "\n";
        infoLibro += "ISBN: " + this.ISBN + "\n";
        infoLibro += "Fecha de publicacion: " + this.fechaPublicacion + "\n";
        infoLibro += "Editora: " + this.editora + "\n";
        infoLibro += "Edicion: " + this.edicion + "\n";
        infoLibro += "NPaginas: " + this.nPaginas + "\n";

        // Alternativa usando String.format (no se usa como retorno pero sirve como ejemplo)
        String info = String.format(
                "Libro - Titulo: %s, Autor: %s , Fecha publicacion: %s, Numero de paginas: %s, Edicion: %s, Editorial: %s, ISBN: %s",
                this.titulo, this.autor, this.fechaPublicacion, this.nPaginas, this.edicion, this.editora, this.ISBN
        );

        // Devolvemos la cadena construida
        return infoLibro;
    }
}


Main
import java.time.LocalDateTime; // Clase para manejar fechas y horas actuales.
import java.time.ZoneOffset; // Sirve para convertir fechas a formato Epoch con un huso horario.
import java.time.format.DateTimeFormatter; // Permite dar formato a fechas.
import java.util.Scanner; // Permite leer datos desde el teclado del usuario.

// Clase principal donde empieza la ejecución del programa.
public class Main {

    public static void main(String[] args) {

        // Creamos un formateador de fechas para transformar la fecha a texto con este formato.
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");

        // Mostramos por pantalla la fecha y hora actual formateada.
        System.out.println(LocalDateTime.now().format(dtf));

        // -------------------
        // Conversión de una fecha escrita en texto a un LocalDateTime
        // -------------------
        String fechaTeclado = "23-7-2023 15:00:45"; // Texto con una fecha.
        LocalDateTime.parse(fechaTeclado, dtf);     // La convierte a objeto LocalDateTime (aunque no lo guardamos).

        // -------------------
        // Obtener fecha en formato Epoch (segundos desde 1970)
        // -------------------
        long miEpoch = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC); // Convertimos fecha actual a Epoch.
        LocalDateTime miFecha = LocalDateTime.ofEpochSecond(miEpoch, 0, ZoneOffset.UTC); // Convertimos de Epoch → fecha.

        // -------------------
        // Uso de una función utilitaria que pide datos siguiendo un patrón.
        // Aquí pide un DNI con 7 números + 1 letra.
        // -------------------
        MiUtils.comprobarPatronRepetidamente("[0-9]{7}[a-z A-Z]{1}", "Introduzca el dni");

        // -------------------
        // Crear una biblioteca
        // -------------------
        Biblioteca biblio = new Biblioteca(
                "Bib001",
                "BMS Jado",
                "Pase de Altamira 23",
                "info@bmsjado.es",
                "942-20-23-25"
        );

        // -------------------
        // Crear varios libros predefinidos
        // -------------------
        Libro l1 = new Libro("La comunidad del anillo", "JRR Tolkien", "ISBN123", "23-7-1942", Genero.FANTASIA);
        Libro l2 = new Libro("Las dos torres", "JRR Tolkien", "ISBN456", "23-7-1944", Genero.FANTASIA);
        Libro l3 = new Libro("El retorno del Rey", "JRR Tolkien", "ISBN789", "23-7-1946", Genero.FANTASIA);
        Libro l4 = new Libro("Juegos de tronos", "GRR Martin", "ISBN333", "23-7-1992", Genero.FANTASIA);
        Libro l5 = new Libro("Choque de reyes", "GRR Martin", "ISBN333", "23-7-1992", Genero.FANTASIA);
        Libro l6 = new Libro("Tormenta de espadas", "GRR Martin", "ISBN333", "23-7-1992", Genero.FANTASIA);
        Libro l7 = new Libro("Festin de cuervos", "GRR Martin", "ISBN333", "23-7-1992", Genero.FANTASIA);
        Libro l8 = new Libro("Danza de dragones", "GRR Martin", "ISBN334", "23-7-2011", Genero.FANTASIA);
        Libro l9 = new Libro("El nombre del viento", "Patrick Rothfus", "ISBN335", "23-7-2006", Genero.FANTASIA);
        Libro l10 = new Libro("El temor de un hombre sabio", "Patrick Rothfus", "ISBN335", "23-7-2011", Genero.HISTORICA);

        // Insertar primer libro y comprobar si la inserción fue correcta.
        boolean estado = biblio.insertarLibro(l1);

        if (estado) {
            System.out.println("Libro insertado exitosamente");
        } else {
            System.out.println("Libro no insertado exitosamente");
        }

        // Insertar el resto de libros sin comprobación individual.
        estado = biblio.insertarLibro(l2);
        estado = biblio.insertarLibro(l3);
        estado = biblio.insertarLibro(l4);
        estado = biblio.insertarLibro(l5);
        estado = biblio.insertarLibro(l6);
        estado = biblio.insertarLibro(l7);
        estado = biblio.insertarLibro(l8);
        estado = biblio.insertarLibro(l9);
        estado = biblio.insertarLibro(l10);

        // -------------------
        // Insertar un libro por teclado
        // -------------------
        Scanner sc = new Scanner(System.in); // Creamos el lector del teclado.

        String titulo = "", autor = "", ISBN = "", fechaPublicacion = "";

        // Pedimos los datos al usuario.
        System.out.print("Ingrese el titulo del libro: ");
        titulo = sc.nextLine();

        System.out.print("Ingrese el autor del libro: ");
        autor = sc.nextLine();

        System.out.print("Ingrese el ISBN del libro: ");
        ISBN = sc.nextLine();

        System.out.print("Ingrese el fecha de publicacion del libro: ");
        fechaPublicacion = sc.nextLine();

        // Crear libro con los datos introducidos.
        Libro lTeclado = new Libro(titulo, autor, ISBN, fechaPublicacion, Genero.SCIFI);

        // Insertarlo en la biblioteca.
        biblio.insertarLibro(lTeclado);

        // Mostrar toda la información de la biblioteca.
        System.out.println(biblio.infoBiblioteca());

        // Mostrar los libros almacenados.
        System.out.println(biblio.infoLibros());

        // -------------------
        // Eliminar un libro concreto (l2)
        // -------------------
        boolean isElimnado = biblio.eliminarLibro(l2);

        if (isElimnado) {
            System.out.println("Libro eliminado exitosamente");
        }

        // -------------------
        // Modificar páginas de libros ya insertados
        // -------------------
        l1.setnPaginas(537);
        l3.setnPaginas(645);

        System.out.println(biblio.infoLibros()); // Mostrar lista actualizada.

        // -------------------
        // Eliminar un libro por ISBN introducido por el usuario
        // -------------------
        sc = new Scanner(System.in);
        System.out.print("Ingrese el ISBN del libro que quiere eliminar: ");
        String isbnEliminar = sc.nextLine();

        Libro lEliminar = biblio.getLibroByISBN(isbnEliminar); // Buscar libro.

        biblio.eliminarLibro(lEliminar); // Eliminarlo si existe.

        // Mostrar cuántas bibliotecas se han creado (contador estático).
        System.out.println(Biblioteca.getContadorTotal());
    }
}


Miutils
import java.util.Scanner; // Importamos Scanner para leer datos del teclado.

public class MiUtils {

    // ==========================================================================
    // MÉTODO: generar una letra aleatoria en MAYÚSCULA
    // ==========================================================================
    public static char generarLetraAleatoria() {
        // Math.random() genera un número entre 0.0 y 1.0.
        // (Math.random() * 90) genera un número entre 0 y 90.
        // +1 desplaza el rango para evitar 0.
        // Convertimos el número a entero → esto produce números entre 1 y 90.

        // Math.max(65, número) asegura que nunca sea menor que 65,
        // que es el código ASCII de 'A'.
        char c = (char) Math.max(65, (int) ((Math.random() * 90) + 1));

        // Devolvemos la letra aleatoria generada.
        return c;
    }

    // ==========================================================================
    // MÉTODO: generar un entero aleatorio entre 1 y "max"
    // ==========================================================================
    public static int generarEnteroAleatorio(int max) {
        // (Math.random() * max) genera algo entre 0 y "max".
        // +1 evita que salga 0.
        int resultado = (int) ((Math.random() * max) + 1);

        return resultado;
    }

    // ==========================================================================
    // MÉTODO: leer un número decimal desde teclado
    // ==========================================================================
    public static double leerDecimal(String mensaje) {
        System.out.print(mensaje); // Mostramos el mensaje al usuario.

        Scanner sc = new Scanner(System.in); // Creamos un lector de teclado.

        double numero = sc.nextDouble(); // Leemos un número decimal.

        sc.close(); // Cerramos el Scanner (no recomendado, pero funciona).

        return numero;
    }

    // ==========================================================================
    // MÉTODO: comprobar si un texto coincide con un patrón REGEX
    // ==========================================================================
    public static boolean comprobarPatron(String patron, String texto) {
        boolean resultado = false;

        // .matches() comprueba si el texto encaja exactamente con el patrón.
        resultado = texto.matches(patron);

        return resultado;
    }

    // ==========================================================================
    // MÉTODO: generar un menú en consola y devolver la opción elegida
    // ==========================================================================
    public static String menuConsola(String[] menu) {
        System.out.println("Por favor, escoja una de las opciones:");

        // Mostramos cada línea del menú.
        for (int i = 0; i < menu.length; i++) {
            System.out.println(menu[i]);
        }

        Scanner sc = new Scanner(System.in); // Lector del teclado.
        String opcion = sc.nextLine();        // Leemos la elección del usuario.

        sc.close(); // Cerrar el scanner (PUEDO explicarte por qué no es lo ideal si quieres).

        return opcion;
    }

    // ==========================================================================
    // MÉTODO: imprimir un mensaje (wrapper de System.out.println)
    // ==========================================================================
    public static void imprimir(String mensaje) {
        System.out.println(mensaje);
    }

    // ==========================================================================
    // MÉTODO: leer texto desde teclado mostrando un mensaje primero
    // ==========================================================================
    public static String leerTextoPantalla(String mensaje) {
        Scanner reader = new Scanner(System.in);

        System.out.println(mensaje); // Mostrar el mensaje.
        String valor = reader.nextLine(); // Leer línea completa.

        return valor; // DEVOLVEMOS el texto introducido por el usuario.
        // (NO cerramos el scanner aquí para evitar problemas con System.in)
    }

    // ==========================================================================
    // MÉTODO: pedir texto repetidamente hasta que cumpla un patrón REGEX
    // ==========================================================================
    public static String comprobarPatronRepetidamente(String patron, String mensaje) {
        boolean isOk = false;
        String texto;

        do {
            // Pedimos texto al usuario.
            texto = MiUtils.leerTextoPantalla(mensaje);

            // Comprobamos si cumple el patrón.
            isOk = MiUtils.comprobarPatron(patron, texto);

            // Si es incorrecto, lo avisamos.
            if (!isOk) {
                MiUtils.imprimir("El formato es incorrecto");
            }

        } while (!isOk); // Repetimos hasta que el texto cumpla el patrón.

        // Devolvemos el texto ya validado.
        return texto;
    }

}
